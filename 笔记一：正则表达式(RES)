#一、正则表达式是一个微小且专业的编程语言，使用C语言来编写，通过设置一些规则来匹配你想要的字符串。

#二、利用正则来进行字符匹配
  正则利用特殊字符--元字符，来定义字符类，子组匹配和重复次数，比如：.   ^   $   *   +   ?   { }   [ ]   \   |   ( )等等。没有这些特殊字符，正则就和普通的find函数没有区别。
  1.首先介绍'[]'字符，它可以匹配方括号内的的字符集合可以单个字符，多个字符或用'-'指定区间；比如[abc],可以匹配’a‘，’b‘，’c‘,等同于[a-c]。
     注：元字符在方括号中不会触发“特殊功能”；
         反斜杠真牛逼，反斜杠后边跟元字符去除特殊功能，反斜杠后边跟普通字符实现特殊功能；
         列举一些反斜杠加字符构成的特殊含义：
         \d  匹配任何十进制数字；相当于类 [0-9]
         \s  匹配任何空白字符（包含空格、换行符、制表符等）；相当于类 [ \t\n\r\f\v]
         \w  匹配任何单词字符，当于字符类 [a-zA-Z0-9_]
         \b  匹配单词的开始或结束.
         \（大写字母）表示与小写字母相反含义
     
  2.第二个特殊字符是'*',它用于指定前一个字符匹配零次或者多次。例如 ca*t 将匹配 ct（0 个字符 a），cat（1 个字符 a），caaat（3 个字符 a），等等。
   注：正则表达式默认的匹配规则是贪婪的。
       正则表达式里边不能随意添加空格，不然会改变原来的含义。

   另一个实现重复的元字符是 +，用于指定前一个字符匹配一次或者多次。
   要特别注意 * 和 + 的区别：* 匹配的是零次或者多次，所以被重复的内容可能压根儿不会出现；+ 至少需要出现一次。例如 ca+t 会匹配 cat 和 caaat，但不会匹配 ct。
   还有两个表示重复的元字符，其中一个是问号 ?，用于指定前一个字符匹配零次或者一次。
   最灵活的应该是元字符 {m,n}（m 和 n 都是十进制整数），上边讲到的几个元字符都可以使用它来表达，它的含义是前一个字符必须匹配 m 次到 n 次之间。
   例如 a/{1,3}b 会匹配 a/b，a//b 和 a///b。但不会匹配 ab（没有斜杠）；也不会匹配 a////b（斜杠超过三个）。
   其实 *、+ 和 ? 都可以使用 {m,n} 来代替。{0,} 跟 * 是一样的；{1,} 跟 + 是一样的；
   {0,1} 跟 ? 是一样的。不过还是鼓励大家记住并使用 *、+ 和 ?，因为这些字符更短并且更容易阅读而且效率更高。
   
  3.Python 通过 re 模块为正则表达式引擎提供一个接口，同时允许你将正则表达式编译成模式对象，并用它们来进行匹配。
   正则表达式被编译为模式对象，该对象拥有各种方法供你操作字符串，如查找模式匹配或者执行字符串替换。
   注：强烈建议使用原始字符串来表达正则表达式。
   
   将正则表达式编译之后，你就得到一个模式对象。那你拿他可以用来做什么呢？模式对象拥有很多方法和属性，我们下边列举最重要的几个来讲
    match()	判断一个正则表达式是否从开始处匹配一个字符串
    search()	遍历字符串，找到正则表达式匹配的第一个位置
    findall()	遍历字符串，找到正则表达式匹配的所有位置，并以列表的形式返回
    finditer()	遍历字符串，找到正则表达式匹配的所有位置，并以迭代器的形式返回
    注：如果列表很大，那么返回迭代器的效率要高很多。
    >>> p = re.compile('\d+')
    >>> p.findall('3只小甲鱼，15条腿，多出的3条在哪里？')
     ['3', '15', '3']
  
 3.更多元字符
   '|':或操作符，对两个正则表达式进行或操作。如果 A 和 B 是正则表达式，A | B 会匹配 A 或 B 中出现的任何字符。其优先级特别低。
   '^':匹配字符串的起始位置。如果设置了 MULTILINE 标志，就会变成匹配每一行的起始位置。在 MULTILINE 中，每当遇到换行符就会立刻进行匹配。
   '$':匹配字符串的结束位置，每当遇到换行符也会离开进行匹配。
   '\A':只匹配字符串的起始位置。
   '\Z':只匹配字符串的结束位置。
   '\b':单词边界，这是一个只匹配单词的开始和结尾的零宽断言。“单词”定义为一个字母数字的序列，所以单词的结束指的是空格或者非字母数字的字符。
   '()':跟数学表达式中的小括号含义差不多；它们将包含在内部的表达式组合在一起，所以你可以对一个组的内容使用重复操作的元字符，例如 *，+，? 或者 {m,n}。例如，(ab)* 会匹配零个或者多个 ab：
     注：使用 ( ) 表示的子组我们还可以对它进行按层次索引，可以将索引值作为参数传递给这些方法：group()，start()，end() 和 span()。
     序号 0 表示第一个分组（这个是默认分组，一直存在的，所以不传入参数相当于默认值 0）：
     >>> p = re.compile('(a)b')
     >>> m = p.match('ab')
     >>> m.group()
    'ab'
     >>> m.group(0)
    'ab'
    
      >>> p = re.compile('(a(b)c)d')
      >>> m = p.match('abcd')
      >>> m.group(0)
      'abcd'
      >>> m.group(1)
      'abc'
      >>> m.group(2)
      'b'  
   

  
