一、正则表达式是一个微小且专业的编程语言，使用C语言来编写，通过设置一些规则来匹配你想要的字符串。

二、利用正则来进行字符匹配
  正则利用特殊字符--元字符，来定义字符类，子组匹配和重复次数，比如：.   ^   $   *   +   ?   { }   [ ]   \   |   ( )等等。没有这些特殊字符，正则就和普通的find函数没有区别。
  1.首先介绍'[]'字符，它可以匹配方括号内的的字符集合可以单个字符，多个字符或用'-'指定区间；比如[abc],可以匹配’a‘，’b‘，’c‘,等同于[a-c]。
     注：元字符在方括号中不会触发“特殊功能”；
         反斜杠真牛逼，反斜杠后边跟元字符去除特殊功能，反斜杠后边跟普通字符实现特殊功能；
         列举一些反斜杠加字符构成的特殊含义：
         \d  匹配任何十进制数字；相当于类 [0-9]
         \s  匹配任何空白字符（包含空格、换行符、制表符等）；相当于类 [ \t\n\r\f\v]
         \w  匹配任何单词字符，当于字符类 [a-zA-Z0-9_]
         \b  匹配单词的开始或结束.
         \（大写字母）表示与小写字母相反含义
     
  2.第二个特殊字符是'*',它用于指定前一个字符匹配零次或者多次。例如 ca*t 将匹配 ct（0 个字符 a），cat（1 个字符 a），caaat（3 个字符 a），等等。
   注：正则表达式默认的匹配规则是贪婪的。
       正则表达式里边不能随意添加空格，不然会改变原来的含义。

   另一个实现重复的元字符是 +，用于指定前一个字符匹配一次或者多次。
   要特别注意 * 和 + 的区别：* 匹配的是零次或者多次，所以被重复的内容可能压根儿不会出现；+ 至少需要出现一次。例如 ca+t 会匹配 cat 和 caaat，但不会匹配 ct。
   还有两个表示重复的元字符，其中一个是问号 ?，用于指定前一个字符匹配零次或者一次。
   最灵活的应该是元字符 {m,n}（m 和 n 都是十进制整数），上边讲到的几个元字符都可以使用它来表达，它的含义是前一个字符必须匹配 m 次到 n 次之间。
   例如 a/{1,3}b 会匹配 a/b，a//b 和 a///b。但不会匹配 ab（没有斜杠）；也不会匹配 a////b（斜杠超过三个）。
   其实 *、+ 和 ? 都可以使用 {m,n} 来代替。{0,} 跟 * 是一样的；{1,} 跟 + 是一样的；
   {0,1} 跟 ? 是一样的。不过还是鼓励大家记住并使用 *、+ 和 ?，因为这些字符更短并且更容易阅读而且效率更高。
   
  3.Python 通过 re 模块为正则表达式引擎提供一个接口，同时允许你将正则表达式编译成模式对象，并用它们来进行匹配。
   正则表达式被编译为模式对象，该对象拥有各种方法供你操作字符串，如查找模式匹配或者执行字符串替换。
   注：强烈建议使用原始字符串来表达正则表达式。
   
   将正则表达式编译之后，你就得到一个模式对象。那你拿他可以用来做什么呢？模式对象拥有很多方法和属性，我们下边列举最重要的几个来讲
    match()	判断一个正则表达式是否从开始处匹配一个字符串
    search()	遍历字符串，找到正则表达式匹配的第一个位置
    findall()	遍历字符串，找到正则表达式匹配的所有位置，并以列表的形式返回
    finditer()	遍历字符串，找到正则表达式匹配的所有位置，并以迭代器的形式返回
    注：如果列表很大，那么返回迭代器的效率要高很多。
    >>> p = re.compile('\d+')
    >>> p.findall('3只小甲鱼，15条腿，多出的3条在哪里？')
     ['3', '15', '3']
  
 3.更多元字符
   '|':或操作符，对两个正则表达式进行或操作。如果 A 和 B 是正则表达式，A | B 会匹配 A 或 B 中出现的任何字符。其优先级特别低。
   '^':匹配字符串的起位置。如果设置了 MULTILINE 标志，就会变成匹配每一行的起始位置。在 MULTILINE 中，每当遇到换行符就会立刻进行匹配。
   表示^之后的字符是想在查询文本中开头的。
   '$':匹配字符串的结束位置，每当遇到换行符也会离开进行匹配。
   '\A':只匹配字符串的起始位置。
   '\Z':只匹配字符串的结束位置。
   '\b':单词边界，这是一个只匹配单词的开始和结尾的零宽断言。“单词”定义为一个字母数字的序列，所以单词的结束指的是空格或者非字母数字的字符。
   '()':跟数学表达式中的小括号含义差不多；它们将包含在内部的表达式组合在一起，所以你可以对一个组的内容使用重复操作的元字符，例如 *，+，? 或者 {m,n}。例如，(ab)* 会匹配零个或者多个 ab：
     注：使用 ( ) 表示的子组我们还可以对它进行按层次索引，可以将索引值作为参数传递给这些方法：group()，start()，end() 和 span()。
     序号 0 表示第一个分组（这个是默认分组，一直存在的，所以不传入参数相当于默认值 0）：
     >>> p = re.compile('(a)b')
     >>> m = p.match('ab')
     >>> m.group()
    'ab'
     >>> m.group(0)
    'ab'
    
      >>> p = re.compile('(a(b)c)d')
      >>> m = p.match('abcd')
      >>> m.group(0)
      'abcd'
      >>> m.group(1)
      'abc'
      >>> m.group(2)
      'b'  
   
  4.利用正则表达式修改字符串
    主要的方法有：
   split()	在正则表达式匹配的地方进行分割，并返回一个列表
   通过正则表达式匹配来分割字符串。如果在 RE 中，你使用了捕获组，那么它们的内容会作为一个列表返回。
   你可以通过传入一个 maxsplit 参数来设置分割的数量。如果 maxsplit 的值是非 0，表示至多有 maxsplit 个分割会被处理，剩下的内容作为列表的最后一个元素返回。
   例子： >>> p = re.compile(r'\W+')
          >>> p2 = re.compile(r'(\W+)')  #你使用了捕获组，空格也会会作为一个列表返回
          >>> p.split('This... is a test.')
              ['This', 'is', 'a', 'test', '']
          >>> p2.split('This... is a test.')
              ['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
  
   sub()	找到所有匹配的子字符串，并替换为新的内容
   subn()	跟 sub() 干一样的勾当，但返回新的字符串以及替换的数目
   
   sub(replacement, string[, count=0])
   返回一个字符串，这个字符串从最左边开始，所有 RE 匹配的地方都替换成 replacement。如果没有找到任何匹配，那么返回原字符串。
   可选参数 count 指定最多替换的次数，必须是一个非负值。默认值是 0，意思是替换所有找到的匹配。
   subn() 方法跟 sub() 方法干同样的勾当，但区别是返回值为一个包含有两个元素的元组：一个是替换后的字符串，一个是替换的数目。
   
  5.常见问题
    在使用 re 模块之前，先考虑一下你的问题是否可以用更快速、简单的字符串自带方法来解决。
    match() 函数只会检查 RE 是否在字符串的开始处匹配，而 search() 会遍历整个字符串搜索匹配的内容。记住这一区别很重要。再次强调一下，match() 只会报告一次成功的匹配，并且匹配的位置必须是从字符串的第一个字符开始
    当编译正则表达式时指定 re.VERBOSE 标志是非常有帮助的。因为它允许你可以编辑正则表达式的格式，使之更清楚。
    使用正则表达式分析 HTML 和 XML 是很痛苦的。建议使用 HTML 和 XML 解析器来处理更合适。
    
   6.Python3 正则表达式特殊符号及用法（详细列表）
     https://fishc.com.cn/forum.php?mod=viewthread&tid=57691&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403
     
   本文大多数引用自鱼C论坛（https://fishc.com.cn/forum.php），特此感谢。
